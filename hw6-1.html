<!DOCTYPE html>
<html>
<head>
</head>
<body> 
	<script src="https://threejs.org/build/three.min.js"></script>
	<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

	<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
	<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>
	<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/geometries/TeapotBufferGeometry.js"></script>
	

<script id="myVertexShader-mono" type="x-shader/x-vertex">
  varying vec2 vUv; 
  void main() { 
     gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
     vUv = uv; 
  }
</script>
<script id="myFragmentShader-mono" type="x-shader/x-fragment">
  uniform sampler2D texture; 
  varying vec2 vUv; 
  
  vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
  }
  vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
  }
  
  void main() { 
  	vec3 color = texture2D (texture, vUv).rgb;
  	vec3 hh = rgb2hsv (color);
  	hh.y = 0.0;  // set saturation to 0
  	vec3 cc = hsv2rgb (hh);
  	gl_FragColor = vec4 (cc, 1.0); 
  }
</script>

<script id="myVertexShader" type="x-shader/x-vertex">

	uniform vec3 lightpos;  // world coordinate
    varying vec3 eyelightdir;
    varying vec3 eyenormal;
    varying vec4 eyepos;

  void main() {
	gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
	eyepos = modelViewMatrix * vec4( position, 1.0);
    vec4 eyelightpos= viewMatrix * vec4 (lightpos, 1.0);
    eyelightdir = normalize (eyelightpos.xyz - eyepos.xyz);
    eyenormal = normalMatrix * normal;

  }
</script>
<script id="myFragmentShader" type="x-shader/x-fragment">
 
	varying vec4 eyepos;
	varying vec3 eyelightdir;
	varying vec3 eyenormal;
	uniform float opacity;

    uniform vec3 kcool; 
    uniform vec3 kwarm;
    
	void main() {
        float lDotn = dot (normalize (eyenormal), normalize (eyelightdir));    
        
        vec3 h = normalize(-normalize (eyepos.xyz) + normalize (eyelightdir));
        float shininess = 40.;    
        vec3 specular = pow (dot (eyenormal, h), shininess) *vec3 (1,1,1);
        
        float k = (1. + lDotn)/2.;
        gl_FragColor = vec4(mix (kcool, kwarm, k) + specular, opacity); // built-in: mix url:https://thebookofshaders.com/glossary/?search=mix
    }
</script>

<script>
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()


var camera, scene, renderer;
var Lamp = new THREE.Object3D();
var modelName = "lamp";
var Pencil = new THREE.Object3D();
var modelName = "pencil";
var Chair = new THREE.Object3D();
var modelName = "chair";
var Cabinet = new THREE.Object3D();
var modelName = "cabinet";



var mouse = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var pickables = [];
var toggleLamp = false;
var toggleRoom = false;
var sceneGrey, scene0, sceneColor;
var angle = 0;

init();
animate();

function init() {

  width = window.innerWidth;
  height = window.innerHeight;
  
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(width, height);
  document.body.appendChild(renderer.domElement);
  renderer.setClearColor(0x888888);
  
  renderer.autoClear = false;
  
  camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
  camera.position.y = 80;
  camera.position.z = 400;
  camera.lookAt(new THREE.Vector3(0, 0, 0));
  
  let controls = new THREE.OrbitControls(camera, renderer.domElement);


  window.addEventListener('resize', onWindowResize, false);
  function onWindowResize() {
  	camera.aspect = window.innerWidth / window.innerHeight;
  	camera.updateProjectionMatrix();
  	renderer.setSize(window.innerWidth, window.innerHeight);
  }

  ////////////////////////////////////////////////////////////////
	
	sceneGrey = new THREE.Scene(); //灰階場景
	
	var geometry = new THREE.CylinderGeometry( 3, 2, 30, 32 );
	var mat = new THREE.MeshLambertMaterial( {color: 'brown'} );
	var material = new THREE.MeshLambertMaterial( {color: 0xffff00} );	
	
	//桌子
	var base = new THREE.Object3D();
	var deskMesh = new THREE.Mesh (new THREE.BoxGeometry (60,2,60), mat);
	base.add (deskMesh);
	deskMesh.position.set (0,30,-50);
	deskMesh.castShadow = true
	deskMesh.receiveShadow = true
	//scene.add(base);
	
	//桌子角柱
	var cylinder1 = new THREE.Mesh( geometry, material );
	cylinder1.position.set (20,-15,20);
	deskMesh.add( cylinder1 );
	var cylinder2 = new THREE.Mesh( geometry, material );
	cylinder2.position.set (-20,-15,20);
	deskMesh.add( cylinder2 );
	var cylinder3 = new THREE.Mesh( geometry, material );
	cylinder3.position.set (20,-15,-20);
	deskMesh.add( cylinder3 );
	var cylinder4 = new THREE.Mesh( geometry, material );
	cylinder4.position.set (-20,-15,-20);
	deskMesh.add( cylinder4 );
	
	
	let loader = new THREE.TextureLoader();
	loader.crossOrigin = '';
	texture = loader.load('https://i.imgur.com/FxWCYDP.jpg');
	alpha = loader.load('https://i.imgur.com/29r3otw.png');//簍空圖案
  
	var texMat = new THREE.MeshLambertMaterial({
    map: texture,
	alphaMap: alpha,
    transparent: true,
    side: THREE.DoubleSide
	});
	
	//筆筒
	var geometry = new THREE.CylinderGeometry( 3, 3, 15, 35, 1, true);
	var cylinder = new THREE.Mesh( geometry, texMat );
	cylinder.position.set(0,38,-65);
  
  
	//scene.add( cylinder );//筆筒
	//scene.add (buildModel());//純喫茶
	
	readModel1('lamp', 40);
	readModel2('pencil', 40);
	readModel3('chair', 40);
	readModel4('cabinet', 40);//櫃子
    
	
	//牆面
    var wallTexture = loader.load('https://i.imgur.com/8XAzExW.jpg');
    var wall_negz = new THREE.Mesh(new THREE.PlaneGeometry(300, 100, 100, 100), new THREE.MeshLambertMaterial({
      map: wallTexture
    }));
    wall_negz.position.y = 50;
    var wall_posx = wall_negz.clone();
    var wall_negx = wall_negz.clone();
    wall_negz.position.z = -150;
    wall_negx.position.x = -150;
    wall_negx.rotation.y = Math.PI / 2;
    wall_posx.position.x = 150;
    wall_posx.rotation.y = -Math.PI / 2;
    //scene.add(wall_negz);
    //scene.add(wall_negx);
    //scene.add(wall_posx);	
	
	
	
    // 地板
    let loader1 = new THREE.TextureLoader();
    loader1.setCrossOrigin ('');
    var Texture = loader1.load('https://i.imgur.com/i8CSCF0.jpg');
    Texture.wrapS = THREE.RepeatWrapping;
    Texture.wrapT = THREE.RepeatWrapping;
    Texture.repeat.set(2, 2);
    var floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300, 140, 140), new THREE.MeshLambertMaterial({
      map: Texture,
      side: THREE.DoubleSide
    }));
    floor.rotation.x = Math.PI / 2;
	
	
	let box = buildModel();
	sceneGrey.add (floor, cylinder, box, wall_negz, wall_negx, wall_posx, base);
	
	
	
	
    sceneColor = new THREE.Scene(); //茶壺放這
	sceneColor.add (bulidTeapot());
  
    renderTarget = new THREE.WebGLRenderTarget (width, height);  // full-size RT

    // it seems that
    // one light can not be added to two DIFFERENT scenes ...
    //
    light = new THREE.PointLight( 0xffffff, 1);
    light.position.set( 50, 50, 50 );
    light2 = new THREE.PointLight( 0xffffff, 1);
  
    sceneColor.add (light);
    sceneColor.add (new THREE.PointLightHelper (light,5))
    sceneGrey.add (light2);
	

	
 ////////////////////////////////////////////////////////////////////////
   var uniforms = {
    texture: {
      type: 't',
      value: renderTarget.texture
    } ,
  };

  // scene0: for processing texture
  // camera0: full-screen ortho camera
  // plane0: mesh for texture processing
  scene0 = new THREE.Scene();
  camera0 = new THREE.OrthographicCamera (0, width, height, 0,-10,100);
  
  var vertShader = document.getElementById('myVertexShader-mono').textContent;
  var fragShader = document.getElementById('myFragmentShader-mono').textContent;
  
  shaderMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertShader,
    fragmentShader: fragShader,
    
    depthTest: false,  // no depth test
    depthWrite: false  // do not write depth buffer
  });

  // plane geometry filled the entire screen
  var plane0 = new THREE.Mesh (new THREE.PlaneGeometry(width, height), shaderMaterial);
  scene0.add (plane0);
  plane0.position.set (width/2, height/2, 0);
  
  console.log(sceneGrey);
  
}

function bulidTeapot() {
	
		let alpha = 0.2, beta = 0.6, y = 0.4, b = 0.4;

    	let kblue = new THREE.Vector3(0,0,b);
		let kyellow = new THREE.Vector3(y,y,0);
		let kd = new THREE.Vector3(240/255, 115/255, 26/255); //RGB

		let kcool = kd.clone().multiplyScalar(alpha).add(kblue); //kcool =kd*alpha + kblue
		let kwarm = kd.clone().multiplyScalar(beta).add(kyellow); //kwarm =kd*beta + kblue
		
		teapotMaterial = new THREE.ShaderMaterial({
			uniforms: {
				lightpos: {type: 'v3', value: new THREE.Vector3(0, 30, 20)},
				opacity: {type: 'f', value: 1.0}, //透明度
				kcool: {type: 'v3', value: kcool},
				kwarm: {type: 'v3', value: kwarm},				
			},
			vertexShader: document.getElementById('myVertexShader').textContent,
			fragmentShader: document.getElementById('myFragmentShader').textContent
		});
		
	 　 let mesh = new THREE.Mesh(new THREE.TeapotBufferGeometry(10),  teapotMaterial);
	    mesh.position.set(-8,40,-33);
		return mesh;
		
}

function readModel1 (modelName, targetSize) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('models/');
  
  mtlLoader.load(modelName+'.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('models/');
    objLoader.load(modelName+'.obj', function(object) {
		
	Lamp.add (unitize (object, 30));
	Lamp.position.set(-20,43,-70);
	Lamp.rotation.y = Math.PI*5/3;
	Lamp.traverse (	//模型影子
         function (mesh) {
            if (mesh instanceof THREE.Mesh) {
              mesh.castShadow = true;
              mesh.receiveShadow = true;}
		 }
    );
	sceneGrey.add (Lamp);	

		
    }, onProgress, onError);
  });
}

function readModel2 (modelName, targetSize) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('models/');
  
  mtlLoader.load(modelName+'.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('models/');
    objLoader.load(modelName+'.obj', function(object) {
		
	Pencil.add (unitize (object, 20));
	sceneGrey.add (Pencil);
	Pencil.position.set(-1,40,-65);
	Pencil.rotation.z = Math.PI/18;

		
    }, onProgress, onError);
  });
}

function readModel3 (modelName, targetSize) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('models/');
  
  mtlLoader.load(modelName+'.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('models/');
    objLoader.load(modelName+'.obj', function(object) {
		
	Chair.add (unitize (object, 50));//可改模型大小
	Chair.traverse (	//模型影子
         function (mesh) {
            if (mesh instanceof THREE.Mesh) {
              mesh.castShadow = true;
              mesh.receiveShadow = true;}
		 }
     );
	Chair.position.set(0,25,0);
	Chair.rotation.z = Math.PI/2;
	Chair.rotation.y = Math.PI;
	sceneGrey.add (Chair);
	
    }, onProgress, onError);
  });
}

function readModel4 (modelName, targetSize) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('models/');
  
  mtlLoader.load(modelName+'.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('models/');
    objLoader.load(modelName+'.obj', function(object) {
		
	Cabinet.add (unitize (object, 80));
	Cabinet.position.set(-140,30,-70);
	Cabinet.rotation.y = Math.PI;
	Cabinet.traverse (
         function (mesh) {
            if (mesh instanceof THREE.Mesh) {
              mesh.castShadow = true;
              mesh.receiveShadow = true;}
		 }
    );
	sceneGrey.add (Cabinet);	

		
    }, onProgress, onError);
  });
}

function unitize (object, targetSize) {  
	
	var box3 = new THREE.Box3();
	box3.setFromObject (object);
	var size = new THREE.Vector3();
	size.subVectors (box3.max, box3.min);
	var center = new THREE.Vector3();
	center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
	
	console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
	console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
	
	var objSize = Math.max (size.x, size.y, size.z);
	var scaleSet = targetSize/objSize;
				
	var theObject =  new THREE.Object3D();
	theObject.add (object);
	object.scale.set (scaleSet, scaleSet, scaleSet);
	object.position.set (-center.x*scaleSet, -center.y*scaleSet, -center.z*scaleSet);
	theObject.rotation.y = Math.PI/2;
	return theObject;
}

function buildModel() {
	let geometry = new THREE.Geometry();
	let sq11 = Math.sqrt(11);
  geometry.vertices.push ( new THREE.Vector3(-5, 0, 5) );//0
  geometry.vertices.push ( new THREE.Vector3( 5, 0, 5) );//1
  geometry.vertices.push ( new THREE.Vector3( 5,12, 5) );//2
  geometry.vertices.push ( new THREE.Vector3( 5, 12+sq11, 0) );//3
  geometry.vertices.push ( new THREE.Vector3(-5, 12+sq11, 0) );//4
  geometry.vertices.push ( new THREE.Vector3(-5, 12, 5) );//5
  geometry.vertices.push ( new THREE.Vector3( 5, 12, -5) );//6
  geometry.vertices.push ( new THREE.Vector3(-5, 12, -5) );//7
  geometry.vertices.push ( new THREE.Vector3(-5, 0, -5) );//8
  geometry.vertices.push ( new THREE.Vector3( 5, 0, -5) );//9
  geometry.vertices.push ( new THREE.Vector3( 5, 17, 0) );//10
  geometry.vertices.push ( new THREE.Vector3(-5, 17, 0) );//11
  geometry.vertices.push ( new THREE.Vector3(-3, 13, 0) );//12
  geometry.vertices.push ( new THREE.Vector3( 3, 13, 0) );//13
  
  let face;
  face = new THREE.Face3 ( 0, 1, 2 ); face.materialIndex = 0;//正面
  geometry.faces.push (face);
  face = new THREE.Face3 ( 0, 2, 5 ); face.materialIndex = 0;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 2, 3, 5 ); face.materialIndex = 3;//上面
  geometry.faces.push (face);
  face = new THREE.Face3 ( 3, 4, 5 ); face.materialIndex = 3;
  geometry.faces.push (face);

  face = new THREE.Face3 ( 0, 5, 7 ); face.materialIndex = 1;//左側
  geometry.faces.push (face);
  face = new THREE.Face3 ( 0, 7, 8 ); face.materialIndex = 1;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 1, 9, 6 ); face.materialIndex = 2;//右側
  geometry.faces.push (face);
  face = new THREE.Face3 ( 1, 6, 2 ); face.materialIndex = 2;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 8, 7, 6 ); face.materialIndex = 0;//後面
  geometry.faces.push (face);
  face = new THREE.Face3 ( 8, 6, 9 ); face.materialIndex = 0;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 7, 4, 3 ); face.materialIndex = 3;//上面
  geometry.faces.push (face);
  face = new THREE.Face3 ( 7, 3, 6 ); face.materialIndex = 3;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 3, 10, 11 ); face.materialIndex = 4;
  geometry.faces.push (face);
  face = new THREE.Face3 ( 3, 11, 4 ); face.materialIndex = 4;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 4, 11, 10 ); face.materialIndex = 4;
  geometry.faces.push (face);
  face = new THREE.Face3 ( 4, 10, 3 ); face.materialIndex = 4;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 5, 4, 12 ); face.materialIndex = 6;//左邊內側
  geometry.faces.push (face);
  face = new THREE.Face3 ( 12, 4, 7 ); face.materialIndex = 5;
  geometry.faces.push (face);
  face = new THREE.Face3 ( 5, 12, 7 ); face.materialIndex = 7;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 13, 3, 2 ); face.materialIndex = 8;//右邊內側
  geometry.faces.push (face);
  face = new THREE.Face3 ( 6, 3, 13 ); face.materialIndex = 9;
  geometry.faces.push (face);
  face = new THREE.Face3 ( 6, 13, 2 ); face.materialIndex = 10;
  geometry.faces.push (face);
  
  face = new THREE.Face3 ( 9, 1, 0 ); face.materialIndex = 0;//底面
  geometry.faces.push (face);
  face = new THREE.Face3 ( 9, 0, 8 ); face.materialIndex = 0;
  geometry.faces.push (face);



	geometry.faceVertexUvs[0].push ([new THREE.Vector2(0,0), new THREE.Vector2(1,0), new THREE.Vector2(1,1) ]);	//圖成像
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(0,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,0) ]);	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,1), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(0,0), new THREE.Vector2(1,0), new THREE.Vector2(1,1) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(0,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);//左內側,圖印上去要再改
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,1), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,1), new THREE.Vector2(0.5,0.5), new THREE.Vector2(0,0) ]);
	
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,1), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);//右內側,圖印上去要再改
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,1), new THREE.Vector2(0.5,0.5), new THREE.Vector2(0,0) ]);

	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(1,1), new THREE.Vector2(0,1) ]);
	geometry.faceVertexUvs[0].push ([new THREE.Vector2(1,0), new THREE.Vector2(0,1), new THREE.Vector2(0,0) ]);
  
  geometry.computeFaceNormals();
  geometry.computeVertexNormals();
  
  let loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  
  var materialArray = [];
  
  materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/efa7InI.jpg')}));//正面
  materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/xwhtEGl.jpg')}));//側面
  materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/gMR5acL.jpg')}));//側面
  materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/cYSPRsc.jpg')}));//上面
  materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/UBUz4ig.jpg')}));//最上面
  materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/SqN8gqv.jpg')}));//左內側
  materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/zXjVmdg.jpg')}));//左內側
    materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/ikTMlTl.jpg')}));//左內側
   materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/xz3ABQJ.jpg')}));//右內側
  materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/Oe7WndV.jpg')}));//右內側
    materialArray.push (new THREE.MeshLambertMaterial ({
  map: loader.load ('https://i.imgur.com/pqsnuLC.jpg')}));//右內側
  
  
  let box = new THREE.Mesh (geometry, materialArray);
  box.position.set(20,30,-45);
  //box.castShadow = true
  //box.receiveShadow = true
  return box;
}

function animate() {
  angle += 0.01;
  requestAnimationFrame(animate);
  light.position.set (40*Math.cos(angle), 60, 40*Math.sin(angle));
  light2.copy (light);
  
  // render sceneGrey to renderTarget
  renderer.setRenderTarget (renderTarget);
  renderer.clear();  // clear the buffers of render target 

  // normalMat.colorWrite = true;
  sceneGrey.traverse ( function (obj) {
  	if (obj instanceof THREE.Mesh)
  		obj.material.colorWrite = true;
  });
  
  renderer.render(sceneGrey, camera);

  // switch to screen output    
  renderer.setRenderTarget (null);
  renderer.clearColor();  // clear screen buffers
  renderer.render(scene0, camera0);
  
  // set up blockers from sceneGrey (colorWrite is disabled)
  // normalMat.colorWrite = false;
  sceneGrey.traverse ( function (obj) {
  	if (obj instanceof THREE.Mesh)
  		obj.material.colorWrite = false;
  });
  renderer.render (sceneGrey, camera);
  
  // render sceneColor
  renderer.render(sceneColor, camera);
  
}


</script>
</body>

</html>